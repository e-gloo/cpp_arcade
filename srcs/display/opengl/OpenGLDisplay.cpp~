#include "display/opengl/OpenGLDisplay.hpp"

#include <iostream>
#include <unistd.h>

OpenGLDisplay::OpenGLDisplay() : _title(""), _width(0), _height(0), _event(), _exit(false), _keys()
{
  if (SDL_Init(SDL_INIT_VIDEO) < 0)
    {
      std::cerr << "SDL_Init : " << SDL_GetError() << std::endl;
      exit(1);
    }
}

OpenGLDisplay::~OpenGLDisplay()
{
  SDL_Quit();
}

int		OpenGLDisplay::createWindow(size_t const &length, size_t const &height, std::string const &name)
{
  _width = length;
  _height = height;
  _title = name;
  SDL_WM_SetCaption(_title.c_str(), NULL);
  SDL_SetVideoMode(1024, 800, 32, SDL_OPENGL);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  gluPerspective(45, (double)1024/800, 1, 1000);
  return (0);
}

std::string		OpenGLDisplay::startGame(IGame &game)
{
  bool		running = true;
  char		**map;
  char		key;

  while (running)
    {
      map = game.getMap();
      this->displayMap(map, _width, _height);
      if ((key = readKey()) == 27)
	running = false;
      running = false;
      sleep(2);
    }
  return ("");
}

char            OpenGLDisplay::readKey()
{
  catchEvent();
  if (_keys[SDLK_z])
    {
      _keys[SDLK_z] = false;
      return 'z';
    }
  else if (_keys[SDLK_q])
    {
      _keys[SDLK_q] = false;
      return 'q';
    }
  else if (_keys[SDLK_s])
    {
      _keys[SDLK_s] = false;
      return 's';
    }
  else if (_keys[SDLK_d])
    {
      _keys[SDLK_d] = false;
      return 'd';
    }
  else if (_keys[SDLK_ESCAPE] || _exit)
    return (27);
  return (-1);
}

void            OpenGLDisplay::catchEvent()
{
  SDL_PollEvent(&_event);

  if (_event.type == SDL_KEYDOWN)
    _keys[_event.key.keysym.sym] = true;
  else if (_event.type == SDL_KEYUP)
    _keys[_event.key.keysym.sym] = false;
  else if (_event.type == SDL_QUIT)
    _exit = true;
  _event.type = 0;
}

void		OpenGLDisplay::displayMap(char **map, int const sizeX, int const sizeY)
{
  (void)map;
  (void)sizeX;
  (void)sizeY;
  std::cout << "ok" << std::endl;
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  glBegin(GL_QUADS);
  glColor3d(255, 255, 255);
  glVertex3i(0, 0, 0);
  glVertex3i(0, _width, 0);
  glVertex3i(_height, _width, 0);
  glVertex3i(_height, 0, 0);
  glEnd();

  //equivalent de SDL_Flip() :
  glFlush();
  SDL_GL_SwapBuffers();
}

int		OpenGLDisplay::setShape(int const tileType, std::string const &shape, unsigned int const color, std::string const &textureName)
{
  (void)tileType;
  (void)shape;
  (void)color;
  (void)textureName;
  return (0);
}

extern "C"
{
  IDisplayManager		*getInstance() {return (new OpenGLDisplay()); }
}
